<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://chux0519.github.io/style.css">
    <link rel="stylesheet" href="https://chux0519.github.io/color/hexyoungs.css">

    <link rel="stylesheet" href="https://chux0519.github.io/font-hack-subset.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="https://chux0519.github.io/rss.xml">


        <link rel="shortcut icon" type="image&#x2F;png" href="/favicon.png">
    
    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://chux0519.github.io" style="text-decoration: none;">
                    <div class="logo">
                            chux0519
                        </div>
                </a>
            </div>
        </div>

        <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://chux0519.github.io">main</a></li>
            
                <li class="active"><a href="https://chux0519.github.io/blog">blog</a></li>
            
                <li><a href="https://chux0519.github.io/projects">projects</a></li>
            
                <li><a href="https://github.com/chux0519" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://chux0519.github.io/blog/io-uring-01/">io_uring 接口</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2021-10-10
        </span>

    </div>

    

        
        <div class="post-content">
            <p>接<a href="/blog/io-uring-00/">上回</a></p>
<p>目前来讲，用户应该使用 liburing，不太需要去直接调用底层的 io_uring API，但是去了解 io_uring 本身提供哪些接口是非常有必要的。</p>
<p>接下来会通过一个类似 cat 的程序，来讲解 io_uring 的一些操作。</p>
<span id="continue-reading"></span><h2 id="readv-2-xi-tong-diao-yong">readv(2) 系统调用</h2>
<p>Linux 提供了许多读写操作的系统调用，比如 <a href="https://man7.org/linux/man-pages/man2/read.2.html">read(2)</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write(2)</a></p>
<p>io_uring 常用的是 <a href="https://man7.org/linux/man-pages/man2/readv.2.html">readv(2)</a>, <a href="https://man7.org/linux/man-pages/man2/writev.2.html">writev(2)</a></p>
<p>以读操作为例，readv 被认为优于 read，因为</p>
<ol>
<li>readv 可以一次读取出多个成员，要用 read 的话，往往需要拷贝数据，然后多次调用 read 完成。</li>
<li>readv 操作是原子的，而实现同样功能的多次 read 则不是</li>
</ol>
<h2 id="bu-yong-io-uring">不用 io_uring</h2>
<p>首先作为对比版本，先实现一个没有使用 io_uring 的版本，核心代码如下</p>
<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">read_and_print_file</span><span>(</span><span style="color:#b48ead;">char </span><span>*</span><span style="color:#bf616a;">file_name</span><span>) {
</span><span>    </span><span style="color:#b48ead;">struct</span><span> iovec *iovecs;
</span><span>    </span><span style="color:#b48ead;">int</span><span> file_fd = </span><span style="color:#bf616a;">open</span><span>(file_name, O_RDONLY);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(file_fd &lt; </span><span style="color:#d08770;">0</span><span>) {
</span><span>        </span><span style="color:#96b5b4;">perror</span><span>(&quot;</span><span style="color:#a3be8c;">open</span><span>&quot;);
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>    off_t file_sz = </span><span style="color:#bf616a;">get_file_size</span><span>(file_fd);
</span><span>    off_t bytes_remaining = file_sz;
</span><span>    </span><span style="color:#b48ead;">int</span><span> blocks = (</span><span style="color:#b48ead;">int</span><span>) file_sz / BLOCK_SZ;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(file_sz % BLOCK_SZ) blocks++;
</span><span>    iovecs = </span><span style="color:#96b5b4;">malloc</span><span>(sizeof(</span><span style="color:#b48ead;">struct</span><span> iovec) * blocks);
</span><span>    </span><span style="color:#b48ead;">int</span><span> current_block = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">     * For the file we&#39;re reading, allocate enough blocks to be able to hold
</span><span style="color:#65737e;">     * the file data. Each block is described in an iovec structure, which is
</span><span style="color:#65737e;">     * passed to readv as part of the array of iovecs.
</span><span style="color:#65737e;">     * */
</span><span>    </span><span style="color:#b48ead;">while </span><span>(bytes_remaining) {
</span><span>        off_t bytes_to_read = bytes_remaining;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(bytes_to_read &gt; BLOCK_SZ)
</span><span>            bytes_to_read = BLOCK_SZ;
</span><span>        </span><span style="color:#b48ead;">void </span><span>*buf;
</span><span>        </span><span style="color:#b48ead;">if</span><span>( </span><span style="color:#bf616a;">posix_memalign</span><span>(&amp;buf, BLOCK_SZ, BLOCK_SZ)) {
</span><span>            </span><span style="color:#96b5b4;">perror</span><span>(&quot;</span><span style="color:#a3be8c;">posix_memalign</span><span>&quot;);
</span><span>            </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>        }
</span><span>        iovecs[current_block].</span><span style="color:#bf616a;">iov_base </span><span>= buf;
</span><span>        iovecs[current_block].</span><span style="color:#bf616a;">iov_len </span><span>= bytes_to_read;
</span><span>        current_block++;
</span><span>        bytes_remaining -= bytes_to_read;
</span><span>    }
</span><span>    </span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">     * The readv() call will block until all iovec buffers are filled with
</span><span style="color:#65737e;">     * file data. Once it returns, we should be able to access the file data
</span><span style="color:#65737e;">     * from the iovecs and print them on the console.
</span><span style="color:#65737e;">     * */
</span><span>    </span><span style="color:#b48ead;">int</span><span> ret = </span><span style="color:#bf616a;">readv</span><span>(file_fd, iovecs, blocks);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(ret &lt; </span><span style="color:#d08770;">0</span><span>) {
</span><span>        </span><span style="color:#96b5b4;">perror</span><span>(&quot;</span><span style="color:#a3be8c;">readv</span><span>&quot;);
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; blocks; i++)
</span><span>        </span><span style="color:#bf616a;">output_to_console</span><span>(iovecs[i].</span><span style="color:#bf616a;">iov_base</span><span>, iovecs[i].</span><span style="color:#bf616a;">iov_len</span><span>);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>}
</span></code></pre>
<p>核心思路大致是计算所需要的 iovecs 的大小，然后一次性初始化所需的空间，然后进行一次 readv 调用，最后把 iovecs 中的数据输出出来</p>
<h2 id="io-uring-ban-ben">io_uring 版本</h2>
<p>核心思路是，提交多个 SQE，告诉 io_uring 我们想要调用 readv 读文件，然后 kernel 做完之后，我们去读取 CQEs</p>
<h3 id="cqe-completion-queue-entry">CQE(completion queue entry)</h3>
<p>我们只了解了一些 mental 的概念，现在看实际 CQE 的结构</p>
<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span style="color:#b48ead;">struct </span><span>io_uring_cqe {
</span><span>  __u64  user_data;  </span><span style="color:#65737e;">/* sqe-&gt;user_data submission passed back */
</span><span>  __s32  res;    </span><span style="color:#65737e;">/* result code for this event */
</span><span>  __u32  flags;
</span><span>};
</span></code></pre>
<p>user_data 是在 SQE 传入，CQE 传出的字段。假设这样的场景，我们提交了一堆请求到 SQ，完成时，CQ 里面的顺序是不保证和请求顺序一致的，比如一些操作先完成，另一些后完成，这时调用者需要一些标识之类的来识别 CQE 对应的具体是哪个 SQE。</p>
<p>res 字段则是我们在 SQE 中告诉 kernel 我们想要的系统调用的返回值。</p>
<p>PS: 上面提到 CQE 的顺序不保证和 SQE 一致，实际上是可以设置的，见 <a href="https://kernel.dk/io_uring.pdf">io_uring.pdf</a></p>
<h3 id="sqe-submission-queue-entry">SQE(submission queue entry)</h3>
<p>它的定义更加复杂一些，因为用户是通过它告诉 io_uring 我们想要做什么</p>
<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span style="color:#b48ead;">struct </span><span>io_uring_sqe {
</span><span>    __u8    opcode;         </span><span style="color:#65737e;">/* type of operation for this sqe */
</span><span>    __u8    flags;          </span><span style="color:#65737e;">/* IOSQE_ flags */
</span><span>    __u16   ioprio;         </span><span style="color:#65737e;">/* ioprio for the request */
</span><span>    __s32   fd;             </span><span style="color:#65737e;">/* file descriptor to do IO on */
</span><span>    </span><span style="color:#b48ead;">union </span><span>{
</span><span>        __u64       off;    </span><span style="color:#65737e;">/* offset into file */
</span><span>        __u64       addr2;
</span><span>    };
</span><span>    </span><span style="color:#b48ead;">union </span><span>{
</span><span>        __u64       addr;   </span><span style="color:#65737e;">/* pointer to buffer or iovecs */
</span><span>        __u64       splice_off_in;
</span><span>    };
</span><span>    __u32   len;            </span><span style="color:#65737e;">/* buffer size or number of iovecs */
</span><span>    </span><span style="color:#b48ead;">union </span><span>{
</span><span>        __kernel_rwf_t      rw_flags;
</span><span>        __u32               fsync_flags;
</span><span>        __u16               poll_events;
</span><span>        __u32               sync_range_flags;
</span><span>        __u32               msg_flags;
</span><span>        __u32               timeout_flags;
</span><span>        __u32               accept_flags;
</span><span>        __u32               cancel_flags;
</span><span>        __u32               open_flags;
</span><span>        __u32               statx_flags;
</span><span>        __u32               fadvise_advice;
</span><span>        __u32               splice_flags;
</span><span>    };
</span><span>    </span><span style="color:#65737e;">/* data to be passed back at completion time */
</span><span>    __u64   user_data;
</span><span>    </span><span style="color:#b48ead;">union </span><span>{
</span><span>        </span><span style="color:#b48ead;">struct </span><span>{
</span><span>            </span><span style="color:#65737e;">/* pack this to avoid bogus arm OABI complaints */
</span><span>            </span><span style="color:#b48ead;">union </span><span>{
</span><span>                </span><span style="color:#65737e;">/* index into fixed buffers, if used */
</span><span>                __u16       buf_index;
</span><span>                </span><span style="color:#65737e;">/* for grouped buffer selection */
</span><span>                __u16       buf_group;
</span><span>            } </span><span style="color:#b48ead;">__attribute__</span><span>((packed));
</span><span>            </span><span style="color:#65737e;">/* personality to use, if used */
</span><span>            __u16   personality;
</span><span>            __s32   splice_fd_in;
</span><span>        };
</span><span>        __u64       __pad2[</span><span style="color:#d08770;">3</span><span>];
</span><span>    };
</span><span>};
</span></code></pre>
<p>这里以 cat 为例，我们想要对文件进行 readv 系统调用，那么</p>
<ol>
<li>opcode 设置为 <code>IORING_OP_READV</code> 代表 readv</li>
<li>fd 设置为我们想操作的文件描述符</li>
<li>addr 我们需要传入的 iovec</li>
<li>len 是 iovecs 的长度</li>
</ol>
<h3 id="chu-shi-hua">初始化</h3>
<p><code>io_uring_setup</code> 需要 2 个参数</p>
<ul>
<li>entry 大小，这里的例子使用 1 即可</li>
<li>param <code>io_uring_params</code>，见下面</li>
</ul>
<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span style="color:#b48ead;">struct </span><span>io_uring_params {
</span><span>  __u32 sq_entries;
</span><span>  __u32 cq_entries;
</span><span>  __u32 flags;
</span><span>  __u32 sq_thread_cpu;
</span><span>  __u32 sq_thread_idle;
</span><span>  __u32 resv[</span><span style="color:#d08770;">5</span><span>];
</span><span>  </span><span style="color:#b48ead;">struct</span><span> io_sqring_offsets sq_off;
</span><span>  </span><span style="color:#b48ead;">struct</span><span> io_cqring_offsets cq_off;
</span><span>};
</span></code></pre>
<p>cat 这个例子暂时用不上，因此全部初始化为 0 即可</p>
<p>初始化后会返回一个文件描述符，后续的一些 mmap 操作需要用到</p>
<h3 id="mmap">mmap</h3>
<p>初始化得到文件描述符后，我们需要 mmap 操作，使 kernel-user 共享 CQ 和 SQ 两个 ring buffer，关键代码如下</p>
<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span>  </span><span style="color:#b48ead;">int</span><span> sring_sz = p.</span><span style="color:#bf616a;">sq_off</span><span>.</span><span style="color:#bf616a;">array </span><span>+ p.</span><span style="color:#bf616a;">sq_entries </span><span>* sizeof(</span><span style="color:#b48ead;">unsigned</span><span>);
</span><span>  </span><span style="color:#b48ead;">int</span><span> cring_sz = p.</span><span style="color:#bf616a;">cq_off</span><span>.</span><span style="color:#bf616a;">cqes </span><span>+ p.</span><span style="color:#bf616a;">cq_entries </span><span>* sizeof(</span><span style="color:#b48ead;">struct</span><span> io_uring_cqe);
</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(p.</span><span style="color:#bf616a;">features </span><span>&amp; IORING_FEAT_SINGLE_MMAP) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(cring_sz &gt; sring_sz) {
</span><span>      sring_sz = cring_sz;
</span><span>    }
</span><span>    cring_sz = sring_sz;
</span><span>  }
</span><span>
</span><span>  sq_ptr = </span><span style="color:#bf616a;">mmap</span><span>(</span><span style="color:#d08770;">0</span><span>, sring_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,
</span><span>                s-&gt;ring_fd, IORING_OFF_SQ_RING);
</span><span>  </span><span style="color:#b48ead;">if </span><span>(sq_ptr == MAP_FAILED) {
</span><span>    </span><span style="color:#96b5b4;">perror</span><span>(&quot;</span><span style="color:#a3be8c;">mmap</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(p.</span><span style="color:#bf616a;">features </span><span>&amp; IORING_FEAT_SINGLE_MMAP) {
</span><span>    cq_ptr = sq_ptr;
</span><span>  } </span><span style="color:#b48ead;">else </span><span>{
</span><span>    cq_ptr = </span><span style="color:#bf616a;">mmap</span><span>(</span><span style="color:#d08770;">0</span><span>, cring_sz, PROT_READ | PROT_WRITE,
</span><span>                  MAP_SHARED | MAP_POPULATE, s-&gt;ring_fd, IORING_OFF_CQ_RING);
</span><span>    </span><span style="color:#b48ead;">if </span><span>(cq_ptr == MAP_FAILED) {
</span><span>      </span><span style="color:#96b5b4;">perror</span><span>(&quot;</span><span style="color:#a3be8c;">mmap</span><span>&quot;);
</span><span>      </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#65737e;">/* map in the SQE array */
</span><span>  s-&gt;sqes = </span><span style="color:#bf616a;">mmap</span><span>(</span><span style="color:#d08770;">0</span><span>, p.</span><span style="color:#bf616a;">sq_entries </span><span>* sizeof(</span><span style="color:#b48ead;">struct</span><span> io_uring_sqe),
</span><span>                 PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, s-&gt;ring_fd,
</span><span>                 IORING_OFF_SQES);
</span><span>  </span><span style="color:#b48ead;">if </span><span>(s-&gt;sqes == MAP_FAILED) {
</span><span>    </span><span style="color:#96b5b4;">perror</span><span>(&quot;</span><span style="color:#a3be8c;">mmap</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>  }
</span></code></pre>
<p>Q: 为什么有三次 mmap，CQ, SQ 两个就够了</p>
<p>A: 简单讲，SQ ring buffer 里面是间接地管理 SQE array，SQ ring buffer 存储的是 index，因此还需要 mmap 下面的 array。
而 CQ 的部分，内核是直接映射的 CQE。因此用户还需要为 SQE 的 array 进行一次映射(While the completion queue ring directly indexes the shared array of CQEs, the submission ring has an indirection array in between. The submission side ring buffer is an index into this array, which in turn contains the index into the SQEs.)</p>
<h3 id="shi-yong-ring-buffer">使用 ring buffer</h3>
<p>因为 SQ 和 CQ 的 ring buffer 是内核以及用户共享的内存，在多核的 CPU 上，读写操作的顺序就需要额外注意，我们可能需要一些内存屏障保证读写的正确性。</p>
<p>比如内核更新 CQ 后，用户要保证看到最新的修改。反之，用户更新 SQ，消费 CQ 后，要保证内核看到最新的修改。</p>
<h3 id="xiao-fei-cq">消费 CQ</h3>
<p>对于 CQE 而言，它由 kernel 进行添加，并且更新到 CQ 的 tail，而我们是在用户态读取，这里就需要讨论 memory ordering。</p>
<p>要谨记每一行代码都可能发生 context switch，因此在比较 head 和 tail 前，要用 <code>read_barrier()</code>，确保我们能读到内核的更新。</p>
<p>而消费完 CQE 后，我们更新了 CQ 的 head，要确保内核清楚我们的更新操作，调用了一次 <code>write_barrier()</code></p>
<p>关键代码如下</p>
<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span>  head = *cring-&gt;head;
</span><span>
</span><span>  </span><span style="color:#b48ead;">do </span><span>{
</span><span>    </span><span style="color:#bf616a;">read_barrier</span><span>(); </span><span style="color:#65737e;">/* ensure previous writes are visible */
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(head == *cring-&gt;tail)
</span><span>      </span><span style="color:#b48ead;">break</span><span>;
</span><span>
</span><span>    cqe = &amp;cring-&gt;cqes[head &amp; *s-&gt;cq_ring.</span><span style="color:#bf616a;">ring_mask</span><span>];
</span><span>    fi = (</span><span style="color:#b48ead;">struct</span><span> file_info *)cqe-&gt;user_data;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(cqe-&gt;res &lt; </span><span style="color:#d08770;">0</span><span>)
</span><span>      </span><span style="color:#96b5b4;">fprintf</span><span>(stderr, &quot;</span><span style="color:#a3be8c;">Error: </span><span style="color:#d08770;">%s</span><span style="color:#96b5b4;">\n</span><span>&quot;, </span><span style="color:#96b5b4;">strerror</span><span>(</span><span style="color:#96b5b4;">abs</span><span>(cqe-&gt;res)));
</span><span>
</span><span>    </span><span style="color:#b48ead;">int</span><span> blocks = (</span><span style="color:#b48ead;">int</span><span>)fi-&gt;file_sz / BLOCK_SZ;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(fi-&gt;file_sz % BLOCK_SZ)
</span><span>      blocks++;
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; blocks; i++)
</span><span>      </span><span style="color:#bf616a;">output_to_console</span><span>(fi-&gt;iovecs[i].</span><span style="color:#bf616a;">iov_base</span><span>, fi-&gt;iovecs[i].</span><span style="color:#bf616a;">iov_len</span><span>);
</span><span>
</span><span>    head++;
</span><span>  } </span><span style="color:#b48ead;">while </span><span>(</span><span style="color:#d08770;">1</span><span>);
</span><span>
</span><span>  *cring-&gt;head = head;
</span><span>  </span><span style="color:#bf616a;">write_barrier</span><span>();
</span></code></pre>
<h3 id="ti-jiao-sqe">提交 SQE</h3>
<p>流程大致是，读取当前 tail，获取下一个 tail 的位置，然后在获取 index 前，使用 <code>read_barrier()</code> 保证 tail 和 next_tail 的值是正确写入的。</p>
<p>然后对 sqe 进行了初始化，告诉 kernel 我们需要的操作。</p>
<p>接着更新当前的 tail，使用 <code>write_barrier()</code> 确保 kernel 读到变更。</p>
<p>最后系统调用 <code>io_uring_enter()</code> 把一切交给 kernel</p>
<p>关键代码</p>
<pre data-lang="C" style="background-color:#2b303b;color:#c0c5ce;" class="language-C "><code class="language-C" data-lang="C"><span>  next_tail = tail = *sring-&gt;tail;
</span><span>  next_tail++;
</span><span>  </span><span style="color:#bf616a;">read_barrier</span><span>();
</span><span>  index = tail &amp; *s-&gt;sq_ring.</span><span style="color:#bf616a;">ring_mask</span><span>;
</span><span>  </span><span style="color:#b48ead;">struct</span><span> io_uring_sqe *sqe = &amp;s-&gt;sqes[index];
</span><span>  sqe-&gt;fd = file_fd;
</span><span>  sqe-&gt;flags = </span><span style="color:#d08770;">0</span><span>;
</span><span>  sqe-&gt;opcode = IORING_OP_READV;
</span><span>  sqe-&gt;addr = (</span><span style="color:#b48ead;">unsigned long</span><span>)fi-&gt;iovecs;
</span><span>  sqe-&gt;len = blocks;
</span><span>  sqe-&gt;off = </span><span style="color:#d08770;">0</span><span>;
</span><span>  sqe-&gt;user_data = (</span><span style="color:#b48ead;">unsigned long long</span><span>)fi;
</span><span>  sring-&gt;array[index] = index;
</span><span>  tail = next_tail;
</span><span>
</span><span>  </span><span style="color:#65737e;">/* update the tail so the kernel can see it. */
</span><span>  </span><span style="color:#b48ead;">if </span><span>(*sring-&gt;tail != tail) {
</span><span>    *sring-&gt;tail = tail;
</span><span>    </span><span style="color:#bf616a;">write_barrier</span><span>();
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#b48ead;">int</span><span> ret = </span><span style="color:#bf616a;">io_uring_enter</span><span>(s-&gt;ring_fd, </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">1</span><span>, IORING_ENTER_GETEVENTS);
</span><span>  </span><span style="color:#b48ead;">if </span><span>(ret &lt; </span><span style="color:#d08770;">0</span><span>) {
</span><span>    </span><span style="color:#96b5b4;">perror</span><span>(&quot;</span><span style="color:#a3be8c;">io_uring_enter</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>  }
</span></code></pre>
<h2 id="zi-yuan">资源</h2>
<ul>
<li><a href="https://unixism.net/loti/low_level.html">loti/low_level.html</a></li>
<li><a href="https://unixism.net/2020/04/io-uring-by-example-part-1-introduction/">io-uring-by-example-part-1-introduction</a></li>
<li><a href="https://github.com/chux0519/io_uring_example">代码</a></li>
</ul>

        </div>

        
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright copyright--user">&copy; Copyright 2024 by&nbsp<a href="https://chux0519.github.io">chux0519</a>.</div>
            </div>
    </footer>
    

</div>
</body>

</html>
